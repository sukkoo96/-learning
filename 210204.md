<h1> 프론트엔트 개발자를 위한 자바스크립트 프로그래밍 #6</h1>
<h2>#6 객체 지향 프로그래밍</h2>

<h3> 프로퍼티 타입</h3>

* 프로퍼티에는 데이터 프로퍼티와 접근자 프로퍼티가 있다.

<h4>데이터 프로퍼티</h4>

* 데이터 프로퍼티는 데이터 값에 대한 단 하나의 위치를 포함한다.
이 위치에서 값을 읽고 쓰며, 그 행동을 설명하는 네 가지 속성이 있다.


>[Configurable]
* 해당 프로퍼티가 delete를 통해 삭제하거나, 속성을 바꾸거나, 접근자 프로퍼티로 변환할 수 있는지 나타냄.
* 객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true이다.

>[Enumerable]
* for-in 루프에서 해당 프로퍼티를 반환함을 나타냄
* 객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true이다.

>[Writable]
* 프로퍼티 값을 바꿀수 있음을 나타냄
* 객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true이다.

>[Value]
* 프로퍼티의 실제 데이터 값을 포함.
* 프로퍼티의 값을 읽는 위치이며, 새로운 값을 쓰는 위치.
* 이 속성의 기본값은 undefined이다.



<h4>접근자 프로퍼티</h4>

* 접근자 프로퍼티에는 데이터 값이 들어있지 않는다. 대신 getter, setter함수로 구성된다.
* 접근자 프로퍼티도 네가지 속성이 있다.

>[Configurable]
* 해당 프로퍼티가 delete를 통해 삭제하거나, 속성을 바꾸거나, 접근자 프로퍼티로 변환할 수 있는지 나타냄.
* 객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true이다.

>[Enumerable]
* for-in 루프에서 해당 프로퍼티를 반환함을 나타냄
* 객체에서 직접 정의한 모든 프로퍼티에서 이 속성은 기본적으로 true이다.

>[Get]
* 프로퍼티를 읽을 때 호출할 함수.
* 기본값은 undefined이다.

>[Set]
* 프로퍼티를 바꿀 때 호출할 함수.
* 기본값은 undefined이다.


<h4>팩토리패턴 factory pattern</h4>
* 팩토리 패턴은 특정 객체를 생성하는 과정을 추상화 하는 것
* ECMAScript에는 클래스를 정의할 수 있는 방법이 없으므로 개발자들은 다음과 같이 특정 인터페이스의 객체를 생성하는 과정을 함수로 추상화 했다.

```javascript
function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}

var person1 = createPerson("kendrick", 27, "developer");
var person2 = createPerson("theo", 28, "developer");

Person객체를 만드는 함수를 만들었으며, 필요한 정보를 매개변수로 받아서 객체를 생성,
이 팩토리 패턴을 쓰면 비슷한 객체를 여러 개 만들 때의 코드 중복 문제를 해결 할 수 있다.
하지만 생성한 객체가 어떤 타입인지 알 수 없다.
그 후 자바스크립트가 진화하면서 새로운 패턴이 등장했다.
```

<h4>생성자 패턴 constructor pattern</h4>
이전 예제를 생성자 패턴을 써서 아래와 같이 수정.

```javascript
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    }
}

var person1 = new Person("kendrick", 27, "developer");
var person2 = new Person("theo", 28, "developer");
```

* 명시적으로 객체를 생성하지 않음
* 프로퍼티와 메서드는 this객체에 직접적으로 할당
* return문이 없음
* 생성자 함수는 첫글자를 대문자로 시작하는 표기법 사용(널리쓰이는 표기법)
* Person의 새 인스턴스를 만들때는 new연산자를 사용.


생성자를 이런 식으로 호출하면 내부적으로는 아래와 같은 과정이 이루어진다.

1. 객체를 생성 
2. 생성자의 this 값에 새 객체 할당
3. this가 새 객체를 가리킴 
4. 생성자 내부 코드 실행(객체에 프로퍼티 추가) 새 객체 반환.

스코프에서 호출 할 수도 있다.
```javascript
var o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName();    //Kristen
이렇게 하면 함수의 this값은 객체 o가 되며, 객체 o는 프로퍼티 전부와 sayName() 메서드를 할당 받는다.
```


<h4>프로토타입의 동적 성질</h4>

* 프로토타입에서 값을 찾는 작업은 적시(런타임) 검색이다.
* 프로토타입이 바뀌면 그 내용이 즉시 인스턴스에도 반영된다.
* 프로토타입이 바뀌기전에 빠져나온 인스턴스도 바뀐 내용을 반영한다.

```javascript
var friend = new Person();

Person.prototype.sayhi = function(){
    alert("hi");
}

friend.sayHi(); //"hi" 동작

인스턴스와 프로토타입이 느슨하게 연결되어있기 때문에 위 예제와 같이 인스턴스 생성 후 프로토타입에 함수를 추가 했다 하더라도, 프로토타입에 추후에 추가한 함수에 인스턴스 접근이 가능.
```


``` 
[Prototype] 포인터는 생성자가 호출될 때 할당되므로 프로토타입 객체를 다른 객체로 바꾸면 생성자와 원래 프로토타입의 연결이 끊어집니다. 인스턴스는 프로토타입을 가리키는 포인터를 가질뿐입니다.
```

<h4>네이티브 객체 프로토타입</h4>

* 네이트브 객체도 프로토타입을 통해 기본 메서드 참조 및 새 메서드 정의가 가능
커스텀 객체의 프로토타입과 마찬가지로 메서드 수정, 추가도 할수 있다.


* 네이티브 객체를 수정하면 혼란스럽기도 하며, 같은 이름의 메서드가 어떤 브라우저에서는 지원되고 다른 브라우저에서 지원되지 않는 상황에서 충돌이 발생할 수 있습니다.

<h4>프로토타입의 문제점</h4>

* 일례로 프로토타입 패턴은 초기화 매개변수를 생성자에 전달 할 수 없게 한다.
* 즉 모든 인스턴스가 기본적으로 같은 프로퍼티값을 가지게 된다.

* 프로토타입의 모든 프로퍼티는 모든 인스턴스에서 공유되는데 이런 특징은 함수에는 이상적이다. 하지만 인스턴스에서 프로퍼티에 값을 할당하면 프로토타입 프로퍼티를 가리기 때문에 프로퍼티가 참조값을 포함한 경우 문제가 발생




